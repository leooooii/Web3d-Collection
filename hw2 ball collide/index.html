<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Neon Physics Lab</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      body { margin: 0; background: #050505; overflow: hidden; user-select: none; }
      #canvas-container { width: 100vw; height: 100vh; display: block; }
      
      /* Custom Range Slider Styling */
      input[type=range] {
        -webkit-appearance: none;
        width: 100%;
        background: transparent;
      }
      input[type=range]::-webkit-slider-thumb {
        -webkit-appearance: none;
        height: 16px;
        width: 16px;
        border-radius: 50%;
        background: #06b6d4;
        margin-top: -6px;
        cursor: pointer;
        box-shadow: 0 0 10px rgba(6, 182, 212, 0.5);
      }
      input[type=range]::-webkit-slider-runnable-track {
        width: 100%;
        height: 4px;
        cursor: pointer;
        background: #374151;
        border-radius: 2px;
      }
    </style>
    
    <!-- Import Map for Three.js -->
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
      }
    </script>
  <link rel="stylesheet" href="/index.css">
</head>
  <body>
    <!-- UI Overlay -->
    <div class="absolute top-0 left-0 w-full p-6 pointer-events-none z-10 flex flex-col justify-between h-full font-mono text-white">
        
        <!-- Header -->
        <div class="flex justify-between items-start">
          <div class="bg-black/60 backdrop-blur-md p-4 rounded-lg border border-cyan-500/30 shadow-[0_0_15px_rgba(0,243,255,0.2)]">
            <h1 class="text-2xl font-bold text-cyan-400 tracking-wider uppercase flex items-center gap-2">
              <span class="w-3 h-3 bg-cyan-400 rounded-full animate-pulse"></span>
           Physics Lab
            </h1>
            <p class="text-xs text-gray-400 mt-1"> Three.js</p>
          </div>

          <div class="bg-black/60 backdrop-blur-md p-4 rounded-lg border border-pink-500/30 text-right">
             <div class="text-pink-400 text-sm font-bold">STATUS</div>
             <div id="status-text" class="text-xl text-yellow-400">PAUSED</div>
          </div>
        </div>

        <!-- Footer Controls -->
        <div class="pointer-events-auto flex flex-col items-center gap-4 mb-8">
            
            <div class="bg-black/80 backdrop-blur-lg p-6 rounded-xl border border-gray-700 flex gap-6 items-center shadow-2xl">
              
              <!-- Play/Pause Button -->
              <button id="btn-toggle" class="w-16 h-16 rounded-full flex items-center justify-center transition-all duration-300 transform hover:scale-105 active:scale-95 bg-cyan-500 hover:bg-cyan-400 shadow-[0_0_20px_rgba(6,182,212,0.4)]">
                 <!-- Icon (Play) -->
                 <svg id="icon-play" class="w-8 h-8 text-black fill-current ml-1" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>
                 <!-- Icon (Pause) -->
                 <svg id="icon-pause" class="hidden w-8 h-8 text-black fill-current" viewBox="0 0 24 24"><path d="M6 4h4v16H6V4zm8 0h4v16h-4V4z"/></svg>
              </button>

              <div class="h-10 w-px bg-gray-600 mx-2"></div>

              <!-- Slider Control -->
              <div class="flex flex-col gap-1 w-48">
                <label class="text-xs text-gray-400 uppercase tracking-widest flex justify-between">
                  <span>Spinner RPM</span>
                  <span id="rpm-value" class="text-cyan-400">1.0</span>
                </label>
                <input id="input-rpm" type="range" min="0" max="5" step="0.1" value="1.0">
              </div>

               <!-- Sound Toggle -->
               <button id="btn-sound" class="p-3 rounded-lg border border-green-500/50 text-green-400 bg-green-500/10 transition-colors text-sm font-bold">
                 ðŸ”Š ON
               </button>
            </div>

            <div class="text-gray-500 text-xs uppercase tracking-widest">
              Drag to Rotate Camera â€¢ Scroll to Zoom
            </div>
        </div>
    </div>
	<audio id="collisionsound" style="display:none">
		<source src="../component/" type='audio/wav'>
		</audio>
		
    <!-- 3D Container -->
    <div id="canvas-container"></div>

    <!-- Main Logic -->
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- 1. Audio Engine ---
        class AudioEngine {
            constructor() {
                this.ctx = null;
                this.gainNode = null;
                this.enabled = true;
            }

            init() {
                try {
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                    this.gainNode = this.ctx.createGain();
                    this.gainNode.connect(this.ctx.destination);
                    this.gainNode.gain.value = 0.3;
                } catch (e) {
                    console.warn("Web Audio API not supported");
                }
            }

            resume() {
                if (!this.ctx) this.init();
                if (this.ctx && this.ctx.state === 'suspended') {
                    this.ctx.resume();
                }
            }

            playCollisionSound(impactVelocity) {
                if (!this.enabled || !this.ctx || !this.gainNode) return;

                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();

                const baseFreq = 200 + Math.random() * 100;
                osc.frequency.setValueAtTime(baseFreq, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(baseFreq * 0.5, this.ctx.currentTime + 0.1);

                gain.gain.setValueAtTime(0, this.ctx.currentTime);
                gain.gain.linearRampToValueAtTime(Math.min(impactVelocity / 20, 0.5), this.ctx.currentTime + 0.01);
                gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.15);

                osc.connect(gain);
                gain.connect(this.gainNode);

                osc.type = 'sine';
                osc.start();
                osc.stop(this.ctx.currentTime + 0.2);
            }
        }
        const audioManager = new AudioEngine();

        // --- 2. Physics Logic ---
        const tempVec3_1 = new THREE.Vector3();
        const tempVec3_2 = new THREE.Vector3();
        const tempVec3_3 = new THREE.Vector3();
        const tempMatrix4 = new THREE.Matrix4();

        function resolveBallCollision(b1, b2) {
            const dx = b1.position.x - b2.position.x;
            const dz = b1.position.z - b2.position.z;
            const distSq = dx * dx + dz * dz;
            const minDist = b1.radius + b2.radius;

            if (distSq < minDist * minDist && distSq > 0) {
                const dist = Math.sqrt(distSq);
                const overlap = minDist - dist;
                const nx = dx / dist;
                const nz = dz / dist;
                
                const correction = overlap / 2;
                b1.position.x += nx * correction;
                b1.position.z += nz * correction;
                b2.position.x -= nx * correction;
                b2.position.z -= nz * correction;

                const v1n = b1.velocity.x * nx + b1.velocity.z * nz;
                const v2n = b2.velocity.x * nx + b2.velocity.z * nz;

                // Elastic collision approximation
                const m1 = b1.radius; 
                const m2 = b2.radius;

                const v1nFinal = ((m1 - m2) * v1n + 2 * m2 * v2n) / (m1 + m2);
                const v2nFinal = ((m2 - m1) * v2n + 2 * m1 * v1n) / (m1 + m2);

                b1.velocity.x += (v1nFinal - v1n) * nx;
                b1.velocity.z += (v1nFinal - v1n) * nz;
                b2.velocity.x += (v2nFinal - v2n) * nx;
                b2.velocity.z += (v2nFinal - v2n) * nz;

                // High restitution
                b1.velocity.multiplyScalar(0.99);
                b2.velocity.multiplyScalar(0.99);

                return Math.abs(v1n - v2n);
            }
            return 0;
        }

        function resolveWallCollision(ball, planePoint, planeNormal) {
            tempVec3_1.copy(ball.position).sub(planePoint);
            const distance = tempVec3_1.dot(planeNormal);

            if (distance < ball.radius) {
                const penetration = ball.radius - distance;
                ball.position.addScaledVector(planeNormal, penetration);
                
                const vDotN = ball.velocity.dot(planeNormal);
                if (vDotN < 0) {
                    ball.velocity.sub(planeNormal.clone().multiplyScalar(2 * vDotN));
                    ball.velocity.multiplyScalar(1.0); // Perfect elasticity
                    return Math.abs(vDotN);
                }
            }
            return 0;
        }

        function resolveRotatingBoxCollision(ball, boxMesh) {
            tempMatrix4.copy(boxMesh.matrixWorld).invert();
            const localPos = tempVec3_1.copy(ball.position).applyMatrix4(tempMatrix4);
            
            const widthHalf = boxMesh.geometry.parameters.width / 2;
            const depthHalf = boxMesh.geometry.parameters.depth / 2;

            const closestX = Math.max(-widthHalf, Math.min(widthHalf, localPos.x));
            const closestZ = Math.max(-depthHalf, Math.min(depthHalf, localPos.z));

            tempVec3_2.set(closestX, localPos.y, closestZ);
            
            const distanceVec = tempVec3_3.copy(localPos).sub(tempVec3_2);
            // Ignore Y distance for 2D plane logic mostly
            const dist = Math.sqrt(distanceVec.x * distanceVec.x + distanceVec.z * distanceVec.z);

            if (dist < ball.radius && dist > 0.0001) {
                const normalLocal = distanceVec.normalize();
                const normalWorld = normalLocal.applyQuaternion(boxMesh.quaternion).normalize();

                const penetration = ball.radius - dist;
                ball.position.addScaledVector(normalWorld, penetration);

                const vDotN = ball.velocity.dot(normalWorld);
                if (vDotN < 0) {
                    ball.velocity.sub(normalWorld.multiplyScalar(2 * vDotN));
                    ball.velocity.multiplyScalar(1.3); // Turbo boost from spinner
                    return Math.abs(vDotN);
                }
            }
            return 0;
        }

        // --- 3. Scene Setup ---
        const gameState = {
            isPlaying: false,
            rotationSpeed: 1.0,
        };

        const scene = new THREE.Scene();
        scene.background = new THREE.Color('#050505');
        // Simple fog to simulate the "city" environment preset slightly
        scene.fog = new THREE.FogExp2('#050505', 0.002);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 1000);
        camera.position.set(0, 180, 200);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.5; // BRIGHTER: Increased from 1.2
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.maxPolarAngle = Math.PI / 2 - 0.1;
        controls.minDistance = 100;
        controls.maxDistance = 400;
        controls.enableDamping = true;

        // --- 4. Lights ---
        // BRIGHTER: Increased ambient light intensity
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6); 
        scene.add(ambientLight);

        // BRIGHTER: Significantly increased directional light intensity
        const dirLight = new THREE.DirectionalLight(0xffffff, 4.0);
        dirLight.position.set(100, 100, 50);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        dirLight.shadow.camera.near = 0.5;
        dirLight.shadow.camera.far = 500;
        dirLight.shadow.camera.left = -100;
        dirLight.shadow.camera.right = 100;
        dirLight.shadow.camera.top = 100;
        dirLight.shadow.camera.bottom = -100;
        scene.add(dirLight);

        // BRIGHTER: Stronger point light
        const pointLight = new THREE.PointLight(0xffffff, 10, 500);
        pointLight.position.set(0, 50, 0);
        scene.add(pointLight);

        // --- 5. Objects ---
        
        // Grid
        const gridHelper = new THREE.GridHelper(200, 20, 0x333333, 0x333333);
        gridHelper.position.y = 0.05;
        scene.add(gridHelper);

        // Floor
        const floorGeo = new THREE.PlaneGeometry(1000, 1000);
        const floorMat = new THREE.MeshStandardMaterial({ 
            color: 0xaaaaaa, // Changed from 0x0a0a0a to light gray
            roughness: 0.4, 
            metalness: 0.5 // Reduced metalness to avoid too much darkness from reflection
        });
        const floor = new THREE.Mesh(floorGeo, floorMat);
        floor.rotation.x = -Math.PI / 2;
        floor.position.y = -0.5;
        floor.receiveShadow = true;
        scene.add(floor);

        // Walls (Data & Visuals)
        const wallData = [
            { point: new THREE.Vector3(0, 0, 100), normal: new THREE.Vector3(0, 0, -1) },
            { point: new THREE.Vector3(0, 0, -100), normal: new THREE.Vector3(0, 0, 1) },
            { point: new THREE.Vector3(100, 0, 0), normal: new THREE.Vector3(-1, 0, 0) },
            { point: new THREE.Vector3(-100, 0, 0), normal: new THREE.Vector3(1, 0, 0) },
        ];

        const wallGroup = new THREE.Group();
        const wallGeo = new THREE.BoxGeometry(200, 20, 2);
        const wallMat = new THREE.MeshPhysicalMaterial({
            color: 0xffffff, transmission: 0.9, opacity: 0.5, transparent: true, roughness: 0, thickness: 2
        });
        const glowGeo = new THREE.BoxGeometry(200, 0.5, 2);
        const glowMat = new THREE.MeshBasicMaterial({ color: 0x00f3ff });

        function createWall(x, y, z, rotY) {
            const mesh = new THREE.Mesh(wallGeo, wallMat);
            const glow = new THREE.Mesh(glowGeo, glowMat);
            glow.position.y = 10;
            mesh.add(glow);
            mesh.position.set(x, y, z);
            mesh.rotation.y = rotY;
            wallGroup.add(mesh);
        }

        createWall(0, 10, -100, 0);
        createWall(0, 10, 100, 0);
        createWall(-100, 10, 0, Math.PI / 2);
        createWall(100, 10, 0, Math.PI / 2);
        scene.add(wallGroup);

        // Spinner
        const spinnerGeo = new THREE.BoxGeometry(100, 15, 10);
        const spinnerMat = new THREE.MeshPhysicalMaterial({
            color: 0xff0055, emissive: 0xff0055, emissiveIntensity: 0.5,
            roughness: 0.2, metalness: 0.8, clearcoat: 1
        });
        const spinner = new THREE.Mesh(spinnerGeo, spinnerMat);
        spinner.position.set(0, 7.5, 0);
        spinner.castShadow = true;
        spinner.receiveShadow = true;
        scene.add(spinner);
        
        // BRIGHTER: Stronger pink glow
        const spinnerLight = new THREE.PointLight(0xff0055, 5, 100);
        spinner.add(spinnerLight);

        // Balls
        const balls = [];
        const ballColors = [0x00f3ff, 0xff00aa, 0xffe600, 0x55ff00];
        const ballGeo = new THREE.SphereGeometry(5, 32, 32);

        for (let i = 0; i < 8; i++) {
            const color = ballColors[i % ballColors.length];
            const ballMat = new THREE.MeshPhysicalMaterial({
                color: color, emissive: color, emissiveIntensity: 0.8,
                roughness: 0.1, metalness: 0.1, clearcoat: 1, transmission: 0.2, thickness: 2
            });
            const mesh = new THREE.Mesh(ballGeo, ballMat);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            scene.add(mesh);

            balls.push({
                mesh: mesh,
                position: new THREE.Vector3((Math.random() - 0.5) * 80, 5, (Math.random() - 0.5) * 80),
                velocity: new THREE.Vector3((Math.random() - 0.5) * 80, 0, (Math.random() - 0.5) * 80),
                radius: 5,
                color: color
            });
        }

        // --- 6. Animation Loop ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);

            const delta = clock.getDelta();
            const dt = Math.min(delta, 0.1); // Cap delta

            controls.update();

            if (gameState.isPlaying) {
                // Update Spinner
                spinner.rotation.y += gameState.rotationSpeed * dt;
                spinner.updateMatrixWorld();

                // Update Balls
                balls.forEach((ball, idx) => {
                    // Move
                    ball.position.addScaledVector(ball.velocity, dt);

                    // Cap Velocity
                    const maxSpeed = 150;
                    if (ball.velocity.lengthSq() > maxSpeed * maxSpeed) {
                        ball.velocity.setLength(maxSpeed);
                    }

                    let maxImpact = 0;

                    // Wall Collision
                    wallData.forEach(wall => {
                        const impact = resolveWallCollision(ball, wall.point, wall.normal);
                        maxImpact = Math.max(maxImpact, impact);
                    });

                    // Spinner Collision
                    const spinImpact = resolveRotatingBoxCollision(ball, spinner);
                    maxImpact = Math.max(maxImpact, spinImpact);

                    // Ball Collision
                    for (let j = idx + 1; j < balls.length; j++) {
                        const impact = resolveBallCollision(ball, balls[j]);
                        maxImpact = Math.max(maxImpact, impact);
                    }

                    // Sound
                    if (maxImpact > 10) {
                        audioManager.playCollisionSound(maxImpact);
                    }

                    // Sync Mesh
                    ball.mesh.position.copy(ball.position);
                    ball.mesh.rotation.x += ball.velocity.z * dt * 0.1;
                    ball.mesh.rotation.z -= ball.velocity.x * dt * 0.1;
                });
            } else {
                // Ensure positions are synced even if paused (initially)
                 balls.forEach(ball => {
                    ball.mesh.position.copy(ball.position);
                 });
            }

            renderer.render(scene, camera);
        }

        animate();

        // --- 7. UI Events ---
        const btnToggle = document.getElementById('btn-toggle');
        const iconPlay = document.getElementById('icon-play');
        const iconPause = document.getElementById('icon-pause');
        const statusText = document.getElementById('status-text');
        const inputRpm = document.getElementById('input-rpm');
        const rpmValue = document.getElementById('rpm-value');
        const btnSound = document.getElementById('btn-sound');

        btnToggle.addEventListener('click', () => {
            gameState.isPlaying = !gameState.isPlaying;
            
            // Visual Update
            if (gameState.isPlaying) {
                audioManager.resume();
                btnToggle.classList.remove('bg-cyan-500', 'hover:bg-cyan-400', 'shadow-[0_0_20px_rgba(6,182,212,0.4)]');
                btnToggle.classList.add('bg-yellow-500', 'hover:bg-yellow-400', 'shadow-[0_0_20px_rgba(234,179,8,0.4)]');
                iconPlay.classList.add('hidden');
                iconPause.classList.remove('hidden');
                statusText.innerText = 'SIMULATING';
                statusText.classList.remove('text-yellow-400');
                statusText.classList.add('text-green-400');
            } else {
                btnToggle.classList.add('bg-cyan-500', 'hover:bg-cyan-400', 'shadow-[0_0_20px_rgba(6,182,212,0.4)]');
                btnToggle.classList.remove('bg-yellow-500', 'hover:bg-yellow-400', 'shadow-[0_0_20px_rgba(234,179,8,0.4)]');
                iconPlay.classList.remove('hidden');
                iconPause.classList.add('hidden');
                statusText.innerText = 'PAUSED';
                statusText.classList.add('text-yellow-400');
                statusText.classList.remove('text-green-400');
            }
        });

        inputRpm.addEventListener('input', (e) => {
            gameState.rotationSpeed = parseFloat(e.target.value);
            rpmValue.innerText = gameState.rotationSpeed.toFixed(1);
        });

        btnSound.addEventListener('click', () => {
            audioManager.enabled = !audioManager.enabled;
            if (audioManager.enabled) {
                btnSound.innerHTML = 'ðŸ”Š ON';
                btnSound.classList.remove('border-gray-600', 'text-gray-500');
                btnSound.classList.add('border-green-500/50', 'text-green-400', 'bg-green-500/10');
            } else {
                btnSound.innerHTML = 'ðŸ”‡ OFF';
                btnSound.classList.add('border-gray-600', 'text-gray-500');
                btnSound.classList.remove('border-green-500/50', 'text-green-400', 'bg-green-500/10');
            }
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
  <script type="module" src="/index.tsx"></script>
</body>
</html>